{"posts":[{"title":"关于","content":"&gt; 欢迎来到我的小站呀，很高兴遇见你！🤝 关于本站 -Yis的个人网站 -基于Gridea并部署在Github 如何联系 -邮箱：yi12900@qq.com -B站：https://space.bilibili.com/11233724/ ","link":"https://Yi12900.github.io/post/about/"},{"title":"Opencv：Findcontours","content":"Findcontours的对象最好经过二值化和平滑处理 我采用了自适应二值化和高斯滤波(效果一般)以及腐蚀 //自适应二值化 adaptiveThreshold(gray_M, gray_M, 255, ADAPTIVE_THRESH_GAUSSIAN_C,THRESH_BINARY, 115, -19); //高斯滤波 GaussianBlur(gray_M, gray_M, Size(1, 1), 0, 0); //腐蚀 Mat out; Mat element = getStructuringElement(MORPH_RECT, cv::Size(3, 3)); erode(gray_M, out, element); 处理完成后就可以正式开始使用Findcontours了 首先： vector&lt;vector&lt;Point>> contours; //定义轮廓 vector&lt;Vec4i> hierarchy; //定义存放轮廓结构变量 所定义的轮廓的类型为Point，使用了vector findContours(out, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_NONE, Point()); 此时已经可以将结果绘制 //绘制轮廓 for (int t = 0; t &lt; contours.size(); t++) { drawContours(img, contours, t, Scalar(0, 0, 255), 2, 8); } 又或者绘制其最小外接矩形，并将矩形的参数通过fstream写入txt文件 //绘制最小外接矩形和中心点 vector&lt;Rect> boundRect(contours.size()); //定义外接矩形集合 vector&lt;RotatedRect> box(contours.size()); //定义最小外接矩形集合 Point2f rect&#91;4]; ofstream in; in.open(\"C:\\\\Users\\\\Yis\\\\Desktop\\\\notepad++\\\\com.txt\", ios::trunc); //ios::trunc表示在打开文件前将文件清空,由于是写入,文件不存在则创建 for (int i = 0; i &lt; contours.size(); i++) { box&#91;i] = minAreaRect(Mat(contours&#91;i])); //计算每个轮廓最小外接矩形 boundRect&#91;i] = boundingRect(Mat(contours&#91;i])); circle(img, Point(box&#91;i].center.x, box&#91;i].center.y), 2, Scalar(0, 255, 0), -1, 8); //绘制最小外接矩形的中心点 box&#91;i].points(rect); //把最小外接矩形四个端点复制给rect数组 //rectangle(img, Point(boundRect&#91;i].x, boundRect&#91;i].y), Point(boundRect&#91;i].x + boundRect&#91;i].width, boundRect&#91;i].y + boundRect&#91;i].height), Scalar(0, 255, 0), 2, 8); for (int j = 0; j &lt; 4; j++) { line(img, rect&#91;j], rect&#91;(j + 1) % 4], Scalar(0, 0, 255), 2, 8); //绘制最小外接矩形每条边 } //start loadtxt test in &lt;&lt; box&#91;i].size.width &lt;&lt; '\\t' &lt;&lt; box&#91;i].size.height &lt;&lt; endl;//写入数据 //end } in.close();//关闭文件 运用Findcontours需要注意的地方主要是Point结构和RotatedRect结构 ","link":"https://Yi12900.github.io/post/opencv-findcontours/"},{"title":"MFC：picture控件如何显示mat类型的图片","content":"首先，cv::Mat类型是不能直接显示在mfc的picture控件里 需要一步转换，将Mat转为CImage 我这里通过函数MattoImage实现 代码如下： void MattoImage(Mat&amp; mat, CImage&amp; cImage) { //create new CImage int width = mat.cols; int height = mat.rows; int channels = mat.channels(); cImage.Destroy(); //clear cImage.Create(width, height, //positive: left-bottom-up or negative: left-top-down 8 * channels); //numbers of bits per pixel //copy values uchar* ps; uchar* pimg = (uchar*)cImage.GetBits(); //A pointer to the bitmap buffer //The pitch is the distance, in bytes. represent the beginning of // one bitmap line and the beginning of the next bitmap line int step = cImage.GetPitch(); for (int i = 0; i &lt; height; ++i) { ps = (mat.ptr&lt;uchar>(i)); for (int j = 0; j &lt; width; ++j) { if (channels == 1) //gray { *(pimg + i * step + j) = ps&#91;j]; } else if (channels == 3) //color { for (int k = 0; k &lt; 3; ++k) { *(pimg + i * step + j * 3 + k) = ps&#91;j * 3 + k]; } } } } } 然后就是定义一个CImage占时存放转换后的图片，进行转换 Mat Oimage; CImage image1; MattoImage(Oimage, image1);//类型转换 显示部分如下： CRect rect1; CWnd* pWnd1 = GetDlgItem(IDC_STATIC_1);//picture控件ID:IDC_STATIC_1 CDC* pDC1 = pWnd1->GetDC();//获取DC pWnd1->GetClientRect(&amp;rect1); //取得客户区尺寸 pDC1->SetStretchBltMode(STRETCH_HALFTONE); //保持图片不失真 image1.Draw(pDC1->m_hDC, rect1); //已控件尺寸大小来绘图 ReleaseDC(pDC1);//释放DC image1.Destroy();//释放占时存放转换后图片的CImage","link":"https://Yi12900.github.io/post/MFC/"}]}