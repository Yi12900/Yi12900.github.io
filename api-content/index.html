{"posts":[{"title":"å…³äº","content":"&gt; æ¬¢è¿æ¥åˆ°æˆ‘çš„å°ç«™å‘€ï¼Œå¾ˆé«˜å…´é‡è§ä½ ï¼ğŸ¤ å…³äºæœ¬ç«™ -Yisçš„ä¸ªäººç½‘ç«™ -åŸºäºGrideaå¹¶éƒ¨ç½²åœ¨Github å¦‚ä½•è”ç³» -é‚®ç®±ï¼šyi12900@qq.com -Bç«™ï¼šhttps://space.bilibili.com/11233724/ ","link":"https://Yi12900.github.io/post/about/"},{"title":"Opencvï¼šFindcontours","content":"Findcontoursçš„å¯¹è±¡æœ€å¥½ç»è¿‡äºŒå€¼åŒ–å’Œå¹³æ»‘å¤„ç† æˆ‘é‡‡ç”¨äº†è‡ªé€‚åº”äºŒå€¼åŒ–å’Œé«˜æ–¯æ»¤æ³¢(æ•ˆæœä¸€èˆ¬)ä»¥åŠè…èš€ //è‡ªé€‚åº”äºŒå€¼åŒ– adaptiveThreshold(gray_M, gray_M, 255, ADAPTIVE_THRESH_GAUSSIAN_C,THRESH_BINARY, 115, -19); //é«˜æ–¯æ»¤æ³¢ GaussianBlur(gray_M, gray_M, Size(1, 1), 0, 0); //è…èš€ Mat out; Mat element = getStructuringElement(MORPH_RECT, cv::Size(3, 3)); erode(gray_M, out, element); å¤„ç†å®Œæˆåå°±å¯ä»¥æ­£å¼å¼€å§‹ä½¿ç”¨Findcontoursäº† é¦–å…ˆï¼š vector&lt;vector&lt;Point>> contours; //å®šä¹‰è½®å»“ vector&lt;Vec4i> hierarchy; //å®šä¹‰å­˜æ”¾è½®å»“ç»“æ„å˜é‡ æ‰€å®šä¹‰çš„è½®å»“çš„ç±»å‹ä¸ºPointï¼Œä½¿ç”¨äº†vector findContours(out, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_NONE, Point()); æ­¤æ—¶å·²ç»å¯ä»¥å°†ç»“æœç»˜åˆ¶ //ç»˜åˆ¶è½®å»“ for (int t = 0; t &lt; contours.size(); t++) { drawContours(img, contours, t, Scalar(0, 0, 255), 2, 8); } åˆæˆ–è€…ç»˜åˆ¶å…¶æœ€å°å¤–æ¥çŸ©å½¢ï¼Œå¹¶å°†çŸ©å½¢çš„å‚æ•°é€šè¿‡fstreamå†™å…¥txtæ–‡ä»¶ //ç»˜åˆ¶æœ€å°å¤–æ¥çŸ©å½¢å’Œä¸­å¿ƒç‚¹ vector&lt;Rect> boundRect(contours.size()); //å®šä¹‰å¤–æ¥çŸ©å½¢é›†åˆ vector&lt;RotatedRect> box(contours.size()); //å®šä¹‰æœ€å°å¤–æ¥çŸ©å½¢é›†åˆ Point2f rect&#91;4]; ofstream in; in.open(\"C:\\\\Users\\\\Yis\\\\Desktop\\\\notepad++\\\\com.txt\", ios::trunc); //ios::truncè¡¨ç¤ºåœ¨æ‰“å¼€æ–‡ä»¶å‰å°†æ–‡ä»¶æ¸…ç©º,ç”±äºæ˜¯å†™å…¥,æ–‡ä»¶ä¸å­˜åœ¨åˆ™åˆ›å»º for (int i = 0; i &lt; contours.size(); i++) { box&#91;i] = minAreaRect(Mat(contours&#91;i])); //è®¡ç®—æ¯ä¸ªè½®å»“æœ€å°å¤–æ¥çŸ©å½¢ boundRect&#91;i] = boundingRect(Mat(contours&#91;i])); circle(img, Point(box&#91;i].center.x, box&#91;i].center.y), 2, Scalar(0, 255, 0), -1, 8); //ç»˜åˆ¶æœ€å°å¤–æ¥çŸ©å½¢çš„ä¸­å¿ƒç‚¹ box&#91;i].points(rect); //æŠŠæœ€å°å¤–æ¥çŸ©å½¢å››ä¸ªç«¯ç‚¹å¤åˆ¶ç»™rectæ•°ç»„ //rectangle(img, Point(boundRect&#91;i].x, boundRect&#91;i].y), Point(boundRect&#91;i].x + boundRect&#91;i].width, boundRect&#91;i].y + boundRect&#91;i].height), Scalar(0, 255, 0), 2, 8); for (int j = 0; j &lt; 4; j++) { line(img, rect&#91;j], rect&#91;(j + 1) % 4], Scalar(0, 0, 255), 2, 8); //ç»˜åˆ¶æœ€å°å¤–æ¥çŸ©å½¢æ¯æ¡è¾¹ } //start loadtxt test in &lt;&lt; box&#91;i].size.width &lt;&lt; '\\t' &lt;&lt; box&#91;i].size.height &lt;&lt; endl;//å†™å…¥æ•°æ® //end } in.close();//å…³é—­æ–‡ä»¶ è¿ç”¨Findcontourséœ€è¦æ³¨æ„çš„åœ°æ–¹ä¸»è¦æ˜¯Pointç»“æ„å’ŒRotatedRectç»“æ„ ","link":"https://Yi12900.github.io/post/opencv-findcontours/"},{"title":"MFCï¼špictureæ§ä»¶å¦‚ä½•æ˜¾ç¤ºmatç±»å‹çš„å›¾ç‰‡","content":"é¦–å…ˆï¼Œcv::Matç±»å‹æ˜¯ä¸èƒ½ç›´æ¥æ˜¾ç¤ºåœ¨mfcçš„pictureæ§ä»¶é‡Œ éœ€è¦ä¸€æ­¥è½¬æ¢ï¼Œå°†Matè½¬ä¸ºCImage æˆ‘è¿™é‡Œé€šè¿‡å‡½æ•°MattoImageå®ç° ä»£ç å¦‚ä¸‹ï¼š void MattoImage(Mat&amp; mat, CImage&amp; cImage) { //create new CImage int width = mat.cols; int height = mat.rows; int channels = mat.channels(); cImage.Destroy(); //clear cImage.Create(width, height, //positive: left-bottom-up or negative: left-top-down 8 * channels); //numbers of bits per pixel //copy values uchar* ps; uchar* pimg = (uchar*)cImage.GetBits(); //A pointer to the bitmap buffer //The pitch is the distance, in bytes. represent the beginning of // one bitmap line and the beginning of the next bitmap line int step = cImage.GetPitch(); for (int i = 0; i &lt; height; ++i) { ps = (mat.ptr&lt;uchar>(i)); for (int j = 0; j &lt; width; ++j) { if (channels == 1) //gray { *(pimg + i * step + j) = ps&#91;j]; } else if (channels == 3) //color { for (int k = 0; k &lt; 3; ++k) { *(pimg + i * step + j * 3 + k) = ps&#91;j * 3 + k]; } } } } } ç„¶åå°±æ˜¯å®šä¹‰ä¸€ä¸ªCImageå æ—¶å­˜æ”¾è½¬æ¢åçš„å›¾ç‰‡ï¼Œè¿›è¡Œè½¬æ¢ Mat Oimage; CImage image1; MattoImage(Oimage, image1);//ç±»å‹è½¬æ¢ æ˜¾ç¤ºéƒ¨åˆ†å¦‚ä¸‹ï¼š CRect rect1; CWnd* pWnd1 = GetDlgItem(IDC_STATIC_1);//pictureæ§ä»¶ID:IDC_STATIC_1 CDC* pDC1 = pWnd1->GetDC();//è·å–DC pWnd1->GetClientRect(&amp;rect1); //å–å¾—å®¢æˆ·åŒºå°ºå¯¸ pDC1->SetStretchBltMode(STRETCH_HALFTONE); //ä¿æŒå›¾ç‰‡ä¸å¤±çœŸ image1.Draw(pDC1->m_hDC, rect1); //å·²æ§ä»¶å°ºå¯¸å¤§å°æ¥ç»˜å›¾ ReleaseDC(pDC1);//é‡Šæ”¾DC image1.Destroy();//é‡Šæ”¾å æ—¶å­˜æ”¾è½¬æ¢åå›¾ç‰‡çš„CImage","link":"https://Yi12900.github.io/post/MFC/"}]}